<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<title>Bay Area Cypto Day</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<base href="../">
	
		<link href='assets/img/favicon.ico' rel='icon' type='image/x-icon'>
	<link href='http://fonts.googleapis.com/css?family=Droid+Serif:400,700' rel='stylesheet' type='text/css'>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'>
	
		<link rel="stylesheet" href="assets/css/default.css"/>
	
	<script src="assets/js/vendor/modernizr-2.6.2-respond-1.1.0.min.js"></script>
</head>
<body data-spy="scroll" data-target="#site-navbar">

	<!--[if lt IE 7]>
		<p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
	<![endif]-->
	
	<div id="pg-wrapper">
		<br>
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-center">
					<h1 id="site-title"><a href="">Bay Area Cypto Day</a></h1>
					<h3 class="event-date">
					  
					    April 21, 2017
					  
					</h3>
					<h4 class="event-location">Visa Research (Palo Alto)</h4>
				</div>
			</div>
			<div class="event-container">
			
		        <div class="row">
					<div class="col-md-6">
						<h2 class="event-heading">Program</h2>
					</div>
					<div class="col-md-6"></div>
				</div>
				<div class="row">
					<div class="col-md-12">
						<table class="table">
							
								<tr class="title-row">
									<td width="10%">09:30&ndash;09:40</td>
									<td width="15%">
										
											
									 	
									</td>
									<td>
										
											<b>Welcome</b>
									 	
									</td>
								</tr>
							
								<tr class="title-row">
									<td width="10%">09:40&ndash;10:10</td>
									<td width="15%">
										
											<a href="https://tlepoint.github.io/" target="_blank">Tancrède Lepoint</a>
										
									</td>
									<td>
										
												<a href="#/show-abstract" class="show-abstract" target="_blank">Efficient Post-Quantum Key Exchanges Based On *-LWE</a>
											
										
									</td>
								</tr>
							
							<tr style="display:none" class="abstract-row">
								<td width="10%"></td>
								<td width="15%"></td>
								<td class="abstract-cell">
									<i>Abstract:</i>
									<p>
										<p>TBA</p>
									
									</p>
								</td>
							</tr>
							
								<tr class="title-row">
									<td width="10%">10:10&ndash;10:40</td>
									<td width="15%">
										
											<a href="http://www.cs.rpi.edu/~zikasv/" target="_blank">Vassilis Zikas</a>
										
									</td>
									<td>
										
												<a href="#/show-abstract" class="show-abstract" target="_blank">The Price of Low Communication in Secure Multi-Party Computation</a>
											
										
									</td>
								</tr>
							
							<tr style="display:none" class="abstract-row">
								<td width="10%"></td>
								<td width="15%"></td>
								<td class="abstract-cell">
									<i>Abstract:</i>
									<p>
										<p>Traditional protocols for secure multi-party computation (MPC) among n parties that achieve optimal resiliency communicate at least a linear (in n) number of bits.  In this work  we investigate the feasibility of MPC with sublinear communication complexity. Concretely, we consider two clients, one of which may be corrupted, that wish to perform some joint computation using n servers but do not have any trusted setup. We show that enforcing sublinear message complexity drastically affects the feasibility bounds on the number of corrupted parties that can be tolerated.</p>
<p>We provide a complete investigation of security against semi-honest adversaries---static and adaptive, with or without erasures---and also initiate the study of actively malicious adversaries. In the case of semi-honest static adversaries, our bounds match (up to any constant fraction of corruptions) the corresponding bounds when there is no communication restriction---i.e., we can tolerate up to t &lt; (1/2 -\epsilon)n corrupted parties. For the adaptive case, however, the situation is different. We prove that without erasures a constant fraction of corruptions is intolerable, and---most surprisingly---when erasures are allowed, we prove that t &lt; (1 - \sqrt(0.5) - \epsilon)n corruptions can be tolerated, which we also show to be optimal up to an arbitrarily small constant factor. The latter optimality proof hinges on a new treatment of probabilistic adversary structures which may be of independent interest. In the case of active corruptions in this setting, we prove that static security with abort is feasible when t &lt; (1/2 - \epsilon)n, namely, the bound that is tight for semi-honest security.</p>
<p>This is joint work with Juan Garay, Yuval Ishai, and Rafail Ostrovsky.</p>
									
									</p>
								</td>
							</tr>
							
								<tr class="title-row">
									<td width="10%">10:40&ndash;11:10</td>
									<td width="15%">
										
											<a href="http://research.visa.com/member.html?uid=pmohasse" target="_blank">Payman Mohassel</a>
										
									</td>
									<td>
										
												<a href="#/show-abstract" class="show-abstract" target="_blank">Towards Scalable Privacy-Preserving Machine Learning</a>
											
										
									</td>
								</tr>
							
							<tr style="display:none" class="abstract-row">
								<td width="10%"></td>
								<td width="15%"></td>
								<td class="abstract-cell">
									<i>Abstract:</i>
									<p>
										<p>Machine learning is widely used in practice to produce predictive models for applications such as image processing, speech and text recognition. These models are more accurate when trained on large amount of data collected from different sources. However, the massive data collection raises privacy concerns.</p>
<p>In this talk, I present new and efficient protocols for privacy preserving machine learning for linear regression, logistic regression and neural network training using the stochastic gradient descent method. I also report on experimental results that confirm our protocols are several orders of magnitude faster than the state of the art implementations and scale to millions of data samples with thousands of features.</p>
<p>Joint work with Yupeng Zhang.</p>
									
									</p>
								</td>
							</tr>
							
								<tr class="title-row">
									<td width="10%">11:10&ndash;11:30</td>
									<td width="15%">
										
											
									 	
									</td>
									<td>
										
											<b>Break</b>
									 	
									</td>
								</tr>
							
								<tr class="title-row">
									<td width="10%">11:30&ndash;12:30</td>
									<td width="15%">
										
											<a href="http://web.cs.ucdavis.edu/~rogaway/" target="_blank">Phillip Rogaway</a>
										
									</td>
									<td>
										
												<a href="#/show-abstract" class="show-abstract" target="_blank">The Long Road from Theory to Practice: The Case of Authenticated Encryption</a>
											
										
									</td>
								</tr>
							
							<tr style="display:none" class="abstract-row">
								<td width="10%"></td>
								<td width="15%"></td>
								<td class="abstract-cell">
									<i>Abstract:</i>
									<p>
										<p>To many theory-oriented cryptographers, symmetric encryption is our most passé problem. Yet from the point of view of providing a useful theory and desirable schemes, the area is very much alive. For this talk I’d like to explore the long dialectic that has taken us from semantic security to robust authenticated-encryption.</p>
<p>I’ll trace the history of AE, explaining why it emerged and how it evolved.  AE is rare topic insofar as there has at least been a dialog around identifying what the right problem is. For most topics in cryptography, we seem to travel a road with little but our imagination as guide.</p>
									
									</p>
								</td>
							</tr>
							
								<tr class="title-row">
									<td width="10%">12:30&ndash;14:00</td>
									<td width="15%">
										
											
									 	
									</td>
									<td>
										
											<b>Lunch (provided)</b>
									 	
									</td>
								</tr>
							
								<tr class="title-row">
									<td width="10%">14:00&ndash;14:30</td>
									<td width="15%">
										
											Sam Kim
									 	
									</td>
									<td>
										
												<a href="#/show-abstract" class="show-abstract" target="_blank">Privately Puncturable PRFs From Standard Lattice Assumptions</a>
											
										
									</td>
								</tr>
							
							<tr style="display:none" class="abstract-row">
								<td width="10%"></td>
								<td width="15%"></td>
								<td class="abstract-cell">
									<i>Abstract:</i>
									<p>
										<p>A puncturable pseudorandom function (PRF) has a master key k that enables one to evaluate the PRF at all points of the domain, and has a punctured key k_x that enables one to evaluate the PRF at all points but one. The punctured key k_x reveals no information about the value of the PRF at the punctured point x. In a private puncturable PRF, the punctured key k_x additionally hides the punctured point x. Previous privately puncturable PRF constructions relied on multilinear maps or indistinguishability obfuscation. </p>
<p>We construct the first privately puncturable PRF from standard lattice assumptions, namely from the hardness of learning with errors (LWE) and 1 dimensional short integer solutions (1D-SIS), which have connections to worst-case hardness of general lattice problems. Along the way, we introduce a number of new techniques that can have wider applications in other lattice-based constructions. </p>
<p>This is joint work with Dan Boneh and Hart Montgomery.</p>
									
									</p>
								</td>
							</tr>
							
								<tr class="title-row">
									<td width="10%">14:30&ndash;15:00</td>
									<td width="15%">
										
											<a href="https://people.eecs.berkeley.edu/~peihan/" target="_blank">Peihan Miao</a>
										
									</td>
									<td>
										
												<a href="#/show-abstract" class="show-abstract" target="_blank">Laconic Receiver Oblivious Transfer And Its Applications</a>
											
										
									</td>
								</tr>
							
							<tr style="display:none" class="abstract-row">
								<td width="10%"></td>
								<td width="15%"></td>
								<td class="abstract-cell">
									<i>Abstract:</i>
									<p>
										<p>We introduce a novel technique for secure computation over large inputs. Specifically, we provide a new oblivious transfer (OT) protocol with a laconic receiver. Laconic OT allows a receiver to commit to a large input D (of length M) via a short message. Subsequently, a single short message by a sender allows the receiver to learn m_{D[L]}, where the messages m_0, m_1 and the location L \in [M] are dynamically chosen by the sender. All prior constructions of OT required the receiver&#39;s outgoing message to grow with D.</p>
<p>Our key contribution is an instantiation of this primitive based on the Decisional Diffie-Hellman (DDH) assumption. The technical core of this construction is a novel use of somewhere statistically binding (SSB) hashing in conjunction with hash proof systems. Next, we show applications of laconic OT to non-interactive secure computation on large inputs and multi-hop homomorphic encryption for RAM programs.</p>
<p>Based on joint work with Chongwon Cho, Nico Döttling, Sanjam Garg, Divya Gupta, and Antigoni Polychroniadou.</p>
									
									</p>
								</td>
							</tr>
							
								<tr class="title-row">
									<td width="10%">15:00&ndash;15:30</td>
									<td width="15%">
										
											
									 	
									</td>
									<td>
										
											<b>Break</b>
									 	
									</td>
								</tr>
							
								<tr class="title-row">
									<td width="10%">15:30&ndash;16:00</td>
									<td width="15%">
										
											<a href="https://crypto.stanford.edu/~dwu4/" target="_blank">David Wu</a>
										
									</td>
									<td>
										
												<a href="#/show-abstract" class="show-abstract" target="_blank">Lattice-Based SNARGs and Their Application to More Efficient Obfuscation</a>
											
										
									</td>
								</tr>
							
							<tr style="display:none" class="abstract-row">
								<td width="10%"></td>
								<td width="15%"></td>
								<td class="abstract-cell">
									<i>Abstract:</i>
									<p>
										<p>Succinct non-interactive arguments (SNARGs) enable verifying NP computations with substantially lower complexity than that required for classical NP verification. In this work, we first construct a lattice-based SNARG candidate with quasi-optimal succinctness (where the argument size is quasilinear in the security parameter). Further extension of our methods yields the first SNARG (from any assumption) that is quasi-optimal in terms of both prover overhead (polylogarithmic in the security parameter) as well as succinctness. Moreover, because our constructions are lattice-based, they plausibly resist quantum attacks. Central to our construction is a new notion of linear-only vector encryption which is a generalization of the notion of linear-only encryption introduced by Bitansky et al. (TCC 2013). We conjecture that variants of Regev encryption satisfy our new linear-only definition. Then, together with new information-theoretic approaches for building statistically-sound linear PCPs over small finite fields, we obtain the first quasi-optimal SNARGs.</p>
<p>We then show a surprising connection between our new lattice-based SNARGs and the concrete efficiency of program obfuscation. All existing obfuscation candidates currently rely on multilinear maps. Among the constructions that make black-box use of the multilinear map, obfuscating a circuit of even moderate depth (say, 100) requires a multilinear map with multilinearity degree in excess of 2^100. In this work, we show that an ideal obfuscation of both the decryption function in a fully homomorphic encryption scheme and a variant of the verification algorithm of our new lattice-based SNARG yields a general-purpose obfuscator for all circuits. Finally, we give some concrete estimates needed to obfuscate this “obfuscation-complete” primitive. We estimate that at 80-bits of security, a (black-box) multilinear map with ≈2^12 levels of multilinearity suffices. This is over 2^80 times more efficient than existing candidates, and thus, represents an important milestone towards implementable program obfuscation for all circuits.</p>
									
									</p>
								</td>
							</tr>
							
								<tr class="title-row">
									<td width="10%">16:00&ndash;16:30</td>
									<td width="15%">
										
											Manuel Sabin
									 	
									</td>
									<td>
										
												<a href="#/show-abstract" class="show-abstract" target="_blank">Proofs of Useful Work</a>
											
										
									</td>
								</tr>
							
							<tr style="display:none" class="abstract-row">
								<td width="10%"></td>
								<td width="15%"></td>
								<td class="abstract-cell">
									<i>Abstract:</i>
									<p>
										<p>We give Proofs of Work (PoWs) whose hardness is based on a wide array of computational problems, including Orthogonal Vectors, 3SUM, All-Pairs Shortest Path, and any problem that reduces to them (this includes deciding any graph property that is statable in first-order logic). This results in PoWs whose completion does not waste energy but instead is useful for the solution of computational problems of practical interest.</p>
<p>The PoWs that we propose are based on delegating the evaluation of low-degree polynomials originating from the study of average-case fine-grained complexity. We prove that, beyond being hard on the average (based on worst-case hardness assumptions), the task of evaluating our polynomials cannot be amortized across multiple instances.</p>
<p>For applications such as Bitcoin, which use PoWs on a massive scale, energy is typically wasted in huge proportions. We give a framework that can utilize such otherwise wasteful work.</p>
									
									</p>
								</td>
							</tr>
							

						</table>	
					</div>
				</div>
				<div class="row">
					<div class="col-md-6">
						<h2 class="event-heading">Additional Information</h2>
					</div>
					<div class="col-md-6"></div>
				</div>
				<div class="row">
					<div class="col-md-12">
						<p>
							<p><strong>Location:</strong>
<a href="http://research.visa.com/">Visa Research</a> in Palo Alto.</p>
<p><strong>Registration:</strong>
it is free but mandatory. Please email <code>research@visa.com</code> with the subject &quot;Bay Area Crypto Day&quot; to RSVP (please include your name and affiliation).</p>

						</p>
					</div>
				</div>
				
				<div class="row">
					<div class="col-md-12">
					<br>
					</div>
				</div>
			</div>
			<br>
		</div>
	</div>
	<script src="assets/js/vendor/jquery.min.js"></script>
<script src="assets/js/vendor/bootstrap.js"></script>
<script src="assets/js/plugins.js"></script>
<script src="assets/js/main.js"></script>
<script src="assets/js/app.js"></script>
	<script>
		$(function() {
			$("a.show-abstract").on("click", function(e) {
				e.preventDefault();
				var markupRow = $(this).closest("tr").next("tr.abstract-row");
				markupRow.toggle({
					easing: "swing"
				});
			});
		});
	</script>
</body>
</html>

