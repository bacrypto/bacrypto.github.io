<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<title>Bay Area Crypto Day</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<base href="../">
	
		<link href='assets/img/favicon.ico' rel='icon' type='image/x-icon'>
	<link href='http://fonts.googleapis.com/css?family=Droid+Serif:400,700' rel='stylesheet' type='text/css'>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'>
	
		<link rel="stylesheet" href="assets/css/default.css"/>
	
	<script src="assets/js/vendor/modernizr-2.6.2-respond-1.1.0.min.js"></script>
</head>
<body data-spy="scroll" data-target="#site-navbar">

	<!--[if lt IE 7]>
		<p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
	<![endif]-->
	
	<div id="pg-wrapper">
		<br>
		<div class="container">
			<div class="row">
				<div class="col-md-12 text-center">
					<h1 id="site-title"><a href="">Bay Area Crypto Day</a></h1>
					<h3 class="event-date">
					  
					    November 20, 2015
					  
					</h3>
					<h4 class="event-location">306 Soda Hall (UC Berkeley)</h4>
				</div>
			</div>
			<div class="event-container">
			
		        <div class="row">
					<div class="col-md-6">
						<h2 class="event-heading">Program</h2>
					</div>
					<div class="col-md-6"></div>
				</div>
				<div class="row">
					<div class="col-md-12">
						<table class="table">
							
								<tr class="title-row">
									<td width="10%">09:30&ndash;09:40</td>
									<td width="15%">
										
											
									 	
									</td>
									<td>
										
											<b>Welcome</b>
									 	
									</td>
								</tr>
							
								<tr class="title-row">
									<td width="10%">09:40&ndash;10:10</td>
									<td width="15%">
										
											<a href="http://joye.site88.net/" target="_blank">Marc Joye</a>
										
									</td>
									<td>
										
												<a href="#/show-abstract" class="show-abstract" target="_blank">Private Data Aggregation Over Selected Subset of Users</a>
											
										
									</td>
								</tr>
							
							<tr style="display:none" class="abstract-row">
								<td width="10%"></td>
								<td width="15%"></td>
								<td class="abstract-cell">
									<i>Abstract:</i>
									<p>
										<p>Aggregator-oblivious (AO) encryption is a useful notion that allows an untrusted aggregator to periodically compute aggregate statistics over sensitive data contributed by a set of users.  Such encryption schemes find numerous applications, in particular in the context of privacy-preserving smart metering.  Most existing AO schemes suffer from three main drawbacks:</p>
<ol>
<li><p>Several schemes require the presence of a third-party and additional communication channels between users and these third-parties. In certain settings, such assumptions make the schemes impractical.</p>
</li>
<li><p>Many schemes do not tolerate user failures. Even if a single user fails to report their contribution, the aggregator will not be able to compute anything. In a fault-tolerant scheme, the aggregator is able to compute an aggregate, maybe imprecise, when some users fail.</p>
</li>
<li><p>In most cases, the group of users that are aggregated is static: the keys are dependent on the other users. For many applications, it is desirable to have a dynamic scheme. A dynamic scheme allows users to join or leave a group without redistribution of keys to everyone. With a dynamic scheme, the aggregator can easily perform the aggregation scheme with a subset of users without having to redistribute keys.</p>
</li>
</ol>
<p>This talk will present a number of practical AO encryption schemes, which provably meet the AO security notion under standard complexity assumptions.</p>
									
									</p>
								</td>
							</tr>
							
								<tr class="title-row">
									<td width="10%">10:10&ndash;10:40</td>
									<td width="15%">
										
											<a href="http://pages.cpsc.ucalgary.ca/~pmohasse/" target="_blank">Payman Mohassel</a>
										
									</td>
									<td>
										
												<a href="#/show-abstract" class="show-abstract" target="_blank">Fast and Secure Three-Party Computation: the Garbled Circuit Approach</a>
											
										
									</td>
								</tr>
							
							<tr style="display:none" class="abstract-row">
								<td width="10%"></td>
								<td width="15%"></td>
								<td class="abstract-cell">
									<i>Abstract:</i>
									<p>
										<p>Many deployments of secure multi-party computation (MPC) in practice have used information-theoretic three-party protocols that tolerate a single, semi-honest corrupt party, since these protocols enjoy very high efficiency. In this talk, I will discuss a new protocol and implementation for secure three-party computation (3PC) based on garbled circuits that improves security (malicious security) while maintaining practical efficiency that is competitive with traditional information-theoretic protocols. </p>
<p>Joint Work with Mike Rosulek and Ye Zhang</p>
									
									</p>
								</td>
							</tr>
							
								<tr class="title-row">
									<td width="10%">10:40&ndash;11:00</td>
									<td width="15%">
										
											
									 	
									</td>
									<td>
										
											<b>Break</b>
									 	
									</td>
								</tr>
							
								<tr class="title-row">
									<td width="10%">11:00&ndash;12:00</td>
									<td width="15%">
										
											<a href="https://cseweb.ucsd.edu/~mihir/" target="_blank">Mihir Bellare</a>
										
									</td>
									<td>
										
												<a href="#/show-abstract" class="show-abstract" target="_blank">Keynote: Cryptography in the Age of Mass Surveillance</a>
											
										
									</td>
								</tr>
							
							<tr style="display:none" class="abstract-row">
								<td width="10%"></td>
								<td width="15%"></td>
								<td class="abstract-cell">
									<i>Abstract:</i>
									<p>
										<p>The Snowden revelations expose a mass surveillance program that compromises cryptography in new ways: ways that are not captured by current theoretical models, and that current schemes, accordingly, do not resist. We discuss a research agenda that aims for greater security in this age by crafting models definitions that capture the new threats and then providing schemes meeting these new definitions. Specifically we will discuss algorithm-substitution attacks, key exfiltration via APTs, attacks on randomness and the subversion of public parameters.</p>
									
									</p>
								</td>
							</tr>
							
								<tr class="title-row">
									<td width="10%">12:00&ndash;12:30</td>
									<td width="15%">
										
											<a href="http://theory.stanford.edu/~klewi/" target="_blank">Kevin Lewi</a>
										
									</td>
									<td>
										
												<a href="#/show-abstract" class="show-abstract" target="_blank">Order-Revealing Encryption</a>
											
										
									</td>
								</tr>
							
							<tr style="display:none" class="abstract-row">
								<td width="10%"></td>
								<td width="15%"></td>
								<td class="abstract-cell">
									<i>Abstract:</i>
									<p>
										<p>Deciding “greater-than” relations among data items just given their encryptions is at the heart of search algorithms on encrypted data, most notably, non-interactive binary search on encrypted data. Order-preserving encryption provides one solution, but provably provides only limited security guarantees. Two-input functional encryption is another approach, but requires the full power of obfuscation machinery and is currently not implementable.</p>
<p>We construct the first implementable encryption system, which we call order-revealing encryption, that supports greater-than comparisons on encrypted data and provides the “best-possible” semantic security. In our scheme there is a public algorithm that given two ciphertexts as input, reveals the order of the corresponding plaintexts and nothing else. Our constructions are inspired by obfuscation techniques, but do not use obfuscation, and only rely on multilinear maps.</p>
<p>Then, we study efficient order-revealing encryption schemes from one-way functions. We present the first order-revealing encryption scheme which achieves a simulation-based security notion with respect to a leakage function that precisely specifies what is leaked from encryptions. Our scheme, when composed with existing schemes, is strictly more secure than all other existing non-interactive order-preserving encryption schemes.</p>
<p>Joint works with Dan Boneh, Mariana Raykova, Amit Sahai, Mark Zhandry, and Joe Zimmerman, and also Nathan Chenette, Steve Weis, and David Wu.</p>
									
									</p>
								</td>
							</tr>
							
								<tr class="title-row">
									<td width="10%">12:30&ndash;14:00</td>
									<td width="15%">
										
											
									 	
									</td>
									<td>
										
											<b>Lunch (on your own)</b>
									 	
									</td>
								</tr>
							
								<tr class="title-row">
									<td width="10%">14:00&ndash;14:30</td>
									<td width="15%">
										
											<a href="https://crypto.stanford.edu/~mironov/" target="_blank">Ilya Mironov</a>
										
									</td>
									<td>
										
												<a href="#/show-abstract" class="show-abstract" target="_blank">Message Transmission with Reverse Firewalls---Secure Communication on Corrupted Machines</a>
											
										
									</td>
								</tr>
							
							<tr style="display:none" class="abstract-row">
								<td width="10%"></td>
								<td width="15%"></td>
								<td class="abstract-cell">
									<i>Abstract:</i>
									<p>
										<p>A secure reverse firewall, as recently defined by Mironov and Stephens-Davidowitz, is a third party that &quot;sits between a user and the outside world&quot; and modifies the user&#39;s sent and received messages so that even if the user&#39;s machine has been corrupted, her security is still guaranteed! In other words, reverse firewalls allow us to provide meaningful (and, indeed, very strong) security guarantees against powerful adversaries that may have tampered with the user&#39;s hardware or software (or adversaries that are aware of bugs in the user&#39;s protocol implementation). A long list of recent events and disclosures shows that such threats are extremely common in practice, and they present a serious, arguably existential, threat to cryptography. Importantly, reverse firewalls defend against such threats without sharing any secrets with the user, and in general we expect the user to place no more trust in the firewall than she places in her communication channel.</p>
<p>While Mironov and Stephens-Davidowitz demonstrated that reverse firewalls can be constructed for very strong cryptographic primitives (which are of mostly theoretical interest), we study reverse firewalls for perhaps the most natural cryptographic task: secure message transmission. We find a rich structure of solutions that vary in efficiency, security, and setup assumptions, in close analogy with message transmission in the classical setting. Our strongest and most important result shows a protocol that achieves interactive, concurrent CCA-secure message transmission with a reverse firewall---i.e., CCA-secure message transmission on a possibly compromised machine! Surprisingly, this protocol is quite efficient and simple, requiring only a small constant number of public-key operations. It could easily be used in practice. Behind this result is a technical composition theorem that shows how key agreement with a sufficiently secure reverse firewall can be used to construct a message-transmission protocol with its own secure reverse firewall.</p>
									
									</p>
								</td>
							</tr>
							
								<tr class="title-row">
									<td width="10%">14:30&ndash;15:00</td>
									<td width="15%">
										
											<a href="http://www.cs.berkeley.edu/~omkant/" target="_blank">Omkant Pandey</a>
										
									</td>
									<td>
										
												<a href="#/show-abstract" class="show-abstract" target="_blank">Incremental Program Obfuscation</a>
											
										
									</td>
								</tr>
							
							<tr style="display:none" class="abstract-row">
								<td width="10%"></td>
								<td width="15%"></td>
								<td class="abstract-cell">
									<i>Abstract:</i>
									<p>
										<p>Recent advances in program obfuscation suggest that it is possible to create software that can provably safeguard secret information. However, software systems usually contain large executable code that is updated multiple times and sometimes very frequently. Freshly obfuscating the program for every small update will lead to a considerable efficiency loss. Thus, an extremely desirable property for obfuscation algorithms is {\em incrementality}: small changes to the underlying program translate into small changes to the corresponding obfuscated program.</p>
<p>We initiate a thorough investigation of {\em incremental program obfuscation}. We show that the strong simulation-based notions of program obfuscation, such as &quot;virtual black-box&quot; and &quot;virtual grey-box&quot; obfuscation, cannot be incremental even for very simple functions such as point functions. We then turn to the indistinguishability-based notions, and present two security definitions of varying strength. To understand the overall strength of our definitions, we formulate the notion of {\em incremental best-possible obfuscation} and show that it is equivalent to our (stronger) indistinguishability-based notion.</p>
<p>Finally, we present constructions for incremental program obfuscation satisfying both our security notions. We first give a construction achieving the weaker security notion based on the existence of general purpose indistinguishability obfuscation. Next, we present a generic transformation using {\em oblivious RAM} to amplify security from weaker to stronger, while maintaining the incrementality property.</p>
<p>Joint work with: Sanjam Garg</p>
									
									</p>
								</td>
							</tr>
							
								<tr class="title-row">
									<td width="10%">15:00&ndash;15:30</td>
									<td width="15%">
										
											
									 	
									</td>
									<td>
										
											<b>Break</b>
									 	
									</td>
								</tr>
							
								<tr class="title-row">
									<td width="10%">15:30&ndash;16:00</td>
									<td width="15%">
										
											<a href="http://www.cs.berkeley.edu/~peihan/" target="_blank">Peihan Miao</a>
										
									</td>
									<td>
										
												<a href="#/show-abstract" class="show-abstract" target="_blank">LEGO for Garbled RAM</a>
											
										
									</td>
								</tr>
							
							<tr style="display:none" class="abstract-row">
								<td width="10%"></td>
								<td width="15%"></td>
								<td class="abstract-cell">
									<i>Abstract:</i>
									<p>
										<p>Garbled RAM, introduced by Lu and Ostrovsky in 2013, provides a novel method to garble RAM (Random Access Machine) programs directly. It can be seen as a RAM analogue of Yao&#39;s garbled circuits but achieves much more efficiency than first converting RAM programs into circuits. Secure RAM computation for two-parties is a key application of garbled RAM, but it is secure only against semi-honest adversaries. In this talk I will present LEGO for garbled RAM, a cut-and-choose technique for garbled RAM. This gives the first constant round two-party secure computation protocol for RAM programs secure against malicious adversaries that makes only black-box use of the underlying cryptographic primitives.</p>
									
									</p>
								</td>
							</tr>
							
								<tr class="title-row">
									<td width="10%">16:30&ndash;16:30</td>
									<td width="15%">
										
											<a href="http://crypto.stanford.edu/~dwu4/" target="_blank">David Wu</a>
										
									</td>
									<td>
										
												<a href="#/show-abstract" class="show-abstract" target="_blank">Constraining Pseudorandom Functions Privately</a>
											
										
									</td>
								</tr>
							
							<tr style="display:none" class="abstract-row">
								<td width="10%"></td>
								<td width="15%"></td>
								<td class="abstract-cell">
									<i>Abstract:</i>
									<p>
										<p>In a constrained pseudorandom function (PRF), the holder of the master secret key is able to derive constrained keys with respect to a boolean circuit C. The constrained key can be used to evaluate the PRF on all inputs x for which C(x) = 1. In almost all existing constructions of constrained PRFs, the constrained key itself reveals its underlying constraints. We introduce the concept of private constrained PRFs, which are constrained PRFs with the additional property that the constrained keys do not reveal their constraints. Our main notion of privacy captures the intuition that an adversary, given a constrained key for one of two circuits, is unable to tell which circuit is associated with its key. As a primitive, private constrained PRFs have many natural applications in searchable symmetric encryption, deniable encryption, and more. In this talk, I will introduce our notion of privacy for private constrained PRFs, and describe some of their applications. Finally, I will show how we can construct private constrained PRFs for different classes of constraints using indistinguishability obfuscation or concrete assumptions on multilinear maps.</p>
<p>Joint work with Dan Boneh and Kevin Lewi</p>
									
									</p>
								</td>
							</tr>
							

						</table>	
					</div>
				</div>
				<div class="row">
					<div class="col-md-6">
						<h2 class="event-heading">Additional Information</h2>
					</div>
					<div class="col-md-6"></div>
				</div>
				<div class="row">
					<div class="col-md-12">
						<p>
							<p><strong>Location:</strong>
306 <a href="http://http.cs.berkeley.edu/Directions/">Soda Hall</a>, UC Berkeley.</p>
<p><strong>Parking information:</strong>
Paid visitor parking is available in several parking lots on campus; see <a href="http://pt.berkeley.edu/parking/visitor/lots">here</a> for details. Among these lots, Lower Hearst Garage, Level 2, and Stadium Parking Structure are closest to Soda Hall.</p>
<p><strong>Acknowledgements:</strong>
The organizers kindly thank Pratyay Mukherjee for help on local arrangements.</p>

						</p>
					</div>
				</div>
				
				<div class="row">
					<div class="col-md-12">
					<br>
					</div>
				</div>
				<div class="row">
					<div class="col-md-12">
					<center><a href=""><< back to main page</a></center>
					</div>
				</div>
			</div>
			<br>
		</div>
	</div>
	<script src="assets/js/vendor/jquery.min.js"></script>
<script src="assets/js/vendor/bootstrap.js"></script>
<script src="assets/js/plugins.js"></script>
<script src="assets/js/main.js"></script>
<script src="assets/js/app.js"></script>
	<script>
		$(function() {
			$("a.show-abstract").on("click", function(e) {
				e.preventDefault();
				var markupRow = $(this).closest("tr").next("tr.abstract-row");
				markupRow.toggle({
					easing: "swing"
				});
			});
		});
	</script>
</body>
</html>

